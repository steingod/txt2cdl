#!/usr/bin/perl -w
#
# NAME:
# txt2cdl
#
# PURPOSE:
# To convert various ASCII files to CDL format for subsequent conversion
# to netCDF using ncgen. See function usage for details on supported file
# formats.
#
# REQUIREMENTS:
# o Getopt::Std;
# o Time::Local;
# o Date::Parse; 
# o POSIX qw(strftime);
# o Text::Wrap;
#
# INPUT:
# See function usage 
#
# OUTPUT:
# See function usage 
#
# NOTES:
# NA
#
# BUGS:
# Input checking is yet not properly imeplemented, but baseline
# functionality for the formats supported are implemented.
#
# Directory handling and multiple CTD profiles and levels in moorings are
# yet not implemented. 
#
# AUTHOR:
# Øystein Godøy, METNO/FOU, 09.05.2007 
#
# MODIFIED:
# Øystein Godøy, METNO/FOU, 11.05.2007
# Øystein Godøy, METNO/FOU, 11.03.2008: Added support for WOCE CTD-format.
# Øystein Godøy, METNO/FOU, 17.10.2008: Added support for AWI Helicopter
# Ice Thickness measurements.
# Øystein Godøy, METNO/FOU, 19.10.2008: Adding ITP conversion
#
# CVS_ID:
# $Id: txt2cdl,v 1.10 2008-10-24 09:17:14 steingod Exp $
#  

########################################################### 
# Requirements
use strict;
use Getopt::Std;
use Time::Local;
use Text::Wrap;
use Date::Parse;
#use Date::Format;
use POSIX qw(strftime);
use vars qw($opt_i $opt_o $opt_a $opt_m $opt_t $opt_e $opt_k $opt_v $opt_r $opt_c $opt_g $opt_b $opt_p $opt_h $opt_u $opt_f $opt_n $opt_q);

########################################################### 
# Prototypes
sub usage;
sub year_and_day2epoch;
sub read_file;
sub create_ctd_cdl_woce;
sub create_ctd_cdl_seabirdnfh;
sub create_itp_cdl;
sub create_mooring_cdl_mooringgfi;
sub create_trajectory_cdl_awiem;
sub write_file;

my($ifn,$ofn,@text,$fileformat);
my($template_file, @template, $line, @cdloutput);
my($piname,$title,$topic,$keyw,$email,$area,$inst,$vessel);
my($distribution,$abstract,$history,$url,$pname,$qual);

########################################################### 
# Option decoding
usage if !getopts('i:o:a:m:t:e:k:r:g:v:c:g:p:b:h:u:f:n:q:');
usage if ((! $opt_i) || (!$opt_o) || (!$opt_f) || (!$opt_m));
$ifn = $opt_i;
$ofn = $opt_o;
if ($opt_f) {
    $fileformat = $opt_f;
} else {
    $fileformat = "";
}
if ($opt_g) {
    $inst = $opt_g;
} else {
    $inst = "";
}
if ($opt_a) {
    $piname = $opt_a;
} else {
    $piname = "";
}
if ($opt_t) {
    $title = $opt_t;
} else {
    $title = "";
}
if ($opt_p) {
    $topic = $opt_p;
} else {
    $topic = "";
}
if ($opt_k) {
    $keyw = $opt_k;
} else {
    $keyw = "";
}
if ($opt_e) {
    $email = $opt_e;
} else {
    $email = "";
}
if ($opt_r) {
    $area = $opt_r;
} else {
    $area = "";
}
if ($opt_b) {
    $abstract = $opt_b;
} else {
    $abstract = "";
}
if ($opt_n) {
    $pname = $opt_n;
} else {
    $pname = "";
}
if ($opt_v) {
    $vessel = $opt_v;
} else {
    $vessel = "";
}
if ($opt_c) {
    $distribution = $opt_c;
} else {
    $distribution = "Free";
}
if ($opt_u) {
    $url = $opt_u;
} else {
    $url = "";
}
if ($opt_h) {
    $history = $opt_h;
} else {
    $history = strftime("%F",gmtime(time))." Created";
}
if ($opt_m) {
    $template_file = $opt_m;
} else {
    $template_file = "";
}
if ($opt_q) {
    $qual = $opt_q;
} else {
    $qual = "Unknown quality";
}

###########################################################
# Read template file
print "\n";
print " Reading file: $template_file\n";
@template = read_file($template_file);

########################################################### 
# Read input data
print "\n";
print " Reading file: $ifn\n";
@text = read_file($ifn);

###########################################################
# Extract information from input file and create CDL structure
print "\n";
print " Converting data to CDL\n";
if ($fileformat eq "seabirdnfh") {
    @cdloutput = create_ctd_cdl_seabirdnfh(\@template,\@text);
} elsif ($fileformat eq "wocectd") {
    @cdloutput = create_ctd_cdl_woce(\@template,\@text);
} elsif ($fileformat eq "itp") {
    @cdloutput = create_itp_cdl(\@template,\@text);
} elsif ($fileformat eq "mooringgfi") {
    @cdloutput = create_mooring_cdl_mooringgfi(\@template,\@text);
} elsif ($fileformat eq "awiem") {
    @cdloutput = create_trajectory_cdl_awiem(\@template,\@text);
} else {
    die "Fileformat ($fileformat) is not supported\n";
}

########################################################### 
# Add header information
unless ($fileformat eq "awiem") {
    s/\+title/$title/ for (@cdloutput);
    s/\+abstract/$abstract/ for (@cdloutput);
    s/\+topic/$topic/ for (@cdloutput);
    s/\+keyw/$keyw/ for (@cdloutput);
    s/\+area/$area/ for (@cdloutput);
    s/\+inst/$inst/ for (@cdloutput);
    s/\+piname/$piname/ for (@cdloutput);
    s/\+email/$email/ for (@cdloutput);
    s/\+distribution/$distribution/ for (@cdloutput);
    s/\+vessel/$vessel/ for (@cdloutput);
    s/\+pname/$pname/ for (@cdloutput);
    s/\+history/$history/ for (@cdloutput);
    s/\+url/$url/ for (@cdloutput);
    s/\+qual/$qual/ for (@cdloutput);
}

########################################################### 
# Create output file
$cdloutput[0] =~ s/template_\w+ /$ofn /;
print "\n";
print " Writing file: $ofn\n";
die " Could not write output file\n" if (! write_file($ofn, @cdloutput));
print "\n";

exit;

########################################################### 
#
#
########################################################### 
# Function definitions
########################################################### 
#
#
########################################################### 

sub usage() {
    $Text::Wrap::columns = 74;

    my $text = "This software transforms various ASCII formats into CDL files which can be converted to netCDF by ncgen. The file formats supported may change.";
    my $formats = 
    "o WOCE CTD ASCII format - (format=wocectd)\n".
    "o SeaBird ASCII format by NFH, Tromsø, Norway - (format=seabirdnfh)\n".
    "o Current mooring format by GFI, Bergen, Norway - (format=mooringgfi)\n".
    "o Helicopter trajectory of ice thickness by AWI, Germany - (format=awiem)\n".
    "o ITP-data from Woods Hole, daily updates - (format=itp)\n";
    my $author = "Øystein Godøy, METNO/FOU, 19.10.2008";

    print "\n";
    print wrap("","\t","damascii2cdl -i <infile> -o <outfile> -f <format> -m <template> [-a <author> -e <email> -g <institution> -u <url> -t <title> -b <abstract> -v <platform> -n <product_name> -p <topic> -k <keywords> -r <area_covered> -c <distribution> -h <history> -q <quality>]\n");
    print "\n";
    print "\t<infile>: Some supported ASCII file,\n".
	"\t\tif a directory it tries to process contents\n";
    print "\t<outfile>: CDL file according to CF standard,\n".
	"\t\tif infile is a directory this should be a directory\n";
    print "\t<format>: Input file format, se below\n";
    print "\t<template>: CDL template file according to CF standard, usually in etc\n";
    print "\t<author>: PI name\n";
    print "\t<email>: PI or responsible person email address\n";
    print "\t<institution>: Name of institution\n";
    print "\t<url>: URL of institution/PI\n";
    print "\t<title>: Title of dataset\n";
    print "\t<abstract>: Short description of data\n";
    print "\t<platform>: E.g. name of the research vessel used\n";
    print "\t<product_name>: Product name\n";
    print "\t<topic>: Topic category of dataset (predefined list)\n";
    print "\t<keywords>: Keywords of dataset (predefined list)\n";
    print "\t<area_covered>: Area of observation (predefined list)\n";
    print "\t<distribution>: Data distribution statement (free, restricted)\n";
    print "\t<history>: Short description of data history\n";
    print "\t<quality>: \"Unknown quality\", \"Excellent\",\"Fair\",\"Questionable\"\n";
    print "\n";
    print wrap("\t", "\t", $text);
    print "\n\n";
    print wrap("\t", "\t", $formats);
    print "\n\n";
    print "\t$author\n";
    print "\n";
    exit;
}

# Convert year and decimal days to epoch time
sub year_and_day2epoch($$) {
    my($myyear,$myday) = @_;
    my($timeepoch,$timestr);

    $timestr = sprintf "%4d-01-01 00:00 GMT", $myyear;

    $timeepoch = str2time($timestr);
    $myday *= (60*60);

    $timeepoch += int($myday);

    return($timeepoch);
}

sub read_file($) {

    my($filename) = @_;
    my(@text);

    open FH, "<$filename" or die " Could not open file $filename\n";
    @text = <FH>;
    close FH;

    return(@text);
}

#
# Read and convert WOCE ASCII CTD files
#
sub create_ctd_cdl_woce {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my($tmpstr, $yy, $mm, $dd, $hh, $ii);
    my(@timearr,$timeunix, $timestr);
    my(@mytmp,$pname,$vessel,$lat,$lon,$nvalues);
    my($pres,$temp,$psal);
    my($pres_flg,$temp_flg,$psal_flg);
    my($line,$norec);

    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data

    # Sensor name
    $pname = $txtref->[0];
    $pname =~ s/[\n\r]//;

    # Time
    @mytmp = grep /^DATE = /,@$txtref;
    chop($mytmp[0]);
    $mytmp[0] =~ s/DATE = //g;
    $yy = substr $mytmp[0],0,4;
    $mm = substr $mytmp[0],4,2;
    $dd = substr $mytmp[0],6,2;
    @mytmp = grep /^TIME = /,@$txtref;
    chop($mytmp[0]);
    $mytmp[0] =~ s/TIME = //g;
    $hh = substr $mytmp[0],0,2;
    $ii = substr $mytmp[0],2,2;
    $timestr = sprintf("%4d-%02d-%02d %02d:%02d:%02d UTC", 
	    $yy, $mm, $dd, $hh, $ii, 0);
    $timeunix = str2time($timestr);

    # Vessel
##    @mytmp = grep /^\*\* Ship: /,@$txtref;
##    $vessel = (split /:/,$mytmp[0])[1];
##    $vessel =~ s/^(\s+)//;
##    $vessel =~ s/[\n\r]//g;

    # Latitude
    @mytmp = grep /^LATITUDE = /,@$txtref;
    $lat = substr((split /=/,$mytmp[0])[1],0,-1);

    # Longitude
    @mytmp = grep /^LONGITUDE = /,@$txtref;
    $lon = substr((split /=/,$mytmp[0])[1],0,-1);

    # Data records
    @mytmp = grep /^\ |^[0-9]/,@$txtref;
    s/^(\s+)// for (@mytmp);
    s/\s+/ /g for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	@tmparr = split /,/,$line;
	$pres .= "$tmparr[0],";
	$pres_flg .= "$tmparr[1],";
	$temp .= "$tmparr[2],";
	$temp_flg .= "$tmparr[3],";
	$psal .= "$tmparr[4],";
	$psal_flg .= "$tmparr[5],";
	$norec++;
    }
    print "$norec pressure levels found in file, abort if incorrect...\n";
    $nvalues = $norec;
    $pres =~s/,$//;
    $temp =~s/,$//;
    $psal =~s/,$//;

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+nvalues/$nvalues/ for (@cdlout);
    s/\+pname/$pname/ for (@cdlout); # Actually a global variabel
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+time/$timeunix/ for (@cdlout);
    s/\+YYYY\-MM\-DD HH\:MM\:SS UTC/$timestr/ for (@cdlout);
    s/\+pres/$pres/ for (@cdlout);
    s/\+temp/$temp/ for (@cdlout);
    s/\+psal/$psal/ for (@cdlout);

    return(@cdlout);
}

#
# Read and convert a specific SEABIRD format used by NFH/Tromsø
#
sub create_ctd_cdl_seabirdnfh {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr);
    my(@mytmp,$pname,$vessel,$lat,$lon,$nvalues);
    my($pres,$temp,$cond,$psal);
    my($line,$norec);

    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data
    # stream

    # Sensor name
    $pname = $txtref->[0];
    $pname =~ s/(^(\* ))|://g;
    $pname =~ s/[\n\r]//g;

    # Time
    @mytmp = grep /^\* NMEA UTC \(Time\) = /,@$txtref;
    $timestr = (split /=/,$mytmp[0])[1];
    $timestr =~ s/[\n\r]//g;
    $timestr =~ s/\s+/ /g;
    $timeunix = str2time($timestr);
    @timearr = gmtime($timeunix);
    $timestr = strftime("%F %T UTC",@timearr);

    # Vessel
    @mytmp = grep /^\*\* Ship: /,@$txtref;
    $vessel = (split /:/,$mytmp[0])[1];
    $vessel =~ s/^(\s+)//;
    $vessel =~ s/[\n\r]//g;

    # Latitude
    @mytmp = grep /^\* NMEA Latitude = /,@$txtref;
    $lat = (split /=/,$mytmp[0])[1];
    $lat =~ s/^ //;
    @mytmp = split / /,$lat,3;
    $lat = $mytmp[0]+($mytmp[1]/60.);
    $mytmp[2] =~ s/[\n\r]//g;
    $lat *= (-1.) if ($mytmp[2] eq "S");

    # Longitude
    @mytmp = grep /^\* NMEA Longitude = /,@$txtref;
    $lon = (split /=/,$mytmp[0])[1];
    $lon =~ s/^ //;
    @mytmp = split / /,$lon,3;
    $lon = $mytmp[0]+($mytmp[1]/60.);
    $mytmp[2] =~ s/[\n\r]//g;
    $lon *= (-1.) if ($mytmp[2] eq "W");

    # Nvalues
    @mytmp = grep /^\# nvalues = /,@$txtref;
    $nvalues = (split /=/,$mytmp[0])[1];
    $nvalues =~ s/[\s\n\r]//g;

    # Data records
    @mytmp = grep /^\s/,@$txtref;
    s/^(\s+)// for (@mytmp);
    s/\s+/ /g for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	@tmparr = split / /,$line;
	$pres .= "$tmparr[1],";
	$temp .= "$tmparr[2],";
	$cond .= "$tmparr[3],";
	$psal .= "$tmparr[4],";
	$norec++;
    }
    warn "Data records: nvalues ($nvalues) and norec ($norec) differ\n" if ($nvalues != $norec);
    $pres =~s/,$//;
    $temp =~s/,$//;
    $cond =~s/,$//;
    $psal =~s/,$//;

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+nvalues/$nvalues/ for (@cdlout);
    s/\+pname/$pname/ for (@cdlout); # Actually a global variabel
    s/\+vessel/$vessel/ for (@cdlout); # Actually a global variabel
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+time/$timeunix/ for (@cdlout);
    s/\+YYYY\-MM\-DD HH\:MM\:SS UTC/$timestr/ for (@cdlout);
    s/\+pres/$pres/ for (@cdlout);
    s/\+temp/$temp/ for (@cdlout);
    s/\+cond/$cond/ for (@cdlout);
    s/\+psal/$psal/ for (@cdlout);

    return(@cdlout);
}

#
# Read and convert the mooring format of GFI/UiB
#
sub create_mooring_cdl_mooringgfi {

    my(@cdlout,@tmparr,$tmpstr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr,$timeline);
    my(@mytmp,$pname,$vessel,$lat,$lon,$nvalues);
    my($speed,$directiontemp,$ucomp,$vcomp,$temp,$psal,$pres);
    my($line,$norec,$depth,$instrid,$u,$v,$nlevels,$direction);
    my($start_date,$stop_date,$nparam,$params);
    my($sflg,$dflg,$uflg,$vflg,$tflg,$pflg,$aflg);

    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data
    # stream

    # Header begins with %
    @mytmp = grep /^\%/,@$txtref;

    s/\%// for (@mytmp);
    @tmparr = split /=/,$mytmp[0];

    # Instrument identification
    $instrid = $tmparr[0]; 
    $instrid =~ s/ N.*$//;

    # Parameters in the file, code is as following
    # F - speed, A - direction, U - u component, V - v component,
    # T - temperature, P - pressure, S - salinity
    $params = $tmparr[1];
    $params =~s/^(\s+[0-9]+\s)//g;
    $tmpstr = (split / +/,$params)[0];
    $params = $tmpstr;
    $sflg = ($params =~ /F/)?1:0;
    $dflg = ($params =~ /A/)?1:0;
    $uflg = ($params =~ /U/)?1:0;
    $vflg = ($params =~ /V/)?1:0;
    $tflg = ($params =~ /T/)?1:0;
    $pflg = ($params =~ /P/)?1:0;
    $aflg = ($params =~ /S/)?1:0;

    # Number of datarecords
    $nvalues = $tmparr[1]; 
    $nvalues =~ s/\s|[a-zA-Z]//g;

    # Number of levels
    $nlevels = 1;

    # Date of deployment
    $timestr = sprintf("%4d-%02d-%02d %02d:%02d:%02d UTC",
	    (2000+substr($tmparr[3],0,2)),
	    substr($tmparr[3],2,2),
	    substr($tmparr[3],4,2),
	    substr($tmparr[3],7,2),
	    substr($tmparr[3],9,2),
	    0);
    $start_date = $timestr;

    # Depth
    $depth = $tmparr[4]; 
    $depth =~ s/\s|[a-zA-Z]//g;

    # Latitude
    $tmpstr = $tmparr[5];
    $lat = substr($tmpstr,1,2)+
	(substr($tmpstr,3,2)+(substr($tmpstr,5,2)/100.))/60.;
    $lat *= -1. if ($tmpstr =~ /S/);

    # Longitude
    $lon= substr($tmpstr,8,3)+
	(substr($tmpstr,11,2)+(substr($tmpstr,13,2)/100.))/60.;
    $lon *= -1. if ($tmpstr =~ /W/);

    # Data records
    @mytmp = grep !/(^\%)/,@$txtref;
    s/^(\s+)// for (@mytmp);
    s/\s+/ /g for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	@tmparr = split / /,$line;
	$timearr[0] = 0;
	$timearr[1] = $tmparr[4];
	$timearr[2] = $tmparr[3];
	$timearr[3] = $tmparr[2];
	$timearr[4] = $tmparr[1]-1;
	$timearr[5] = $tmparr[0]+100;
	$timestr = strftime("%F %T UTC",@timearr);
	$timeunix = timegm(@timearr);
	$timeline .= "$timeunix,";
	$speed .= "$tmparr[5]," if ($sflg);
	$direction .= "$tmparr[6]," if ($dflg);
	$u .= "$tmparr[7]," if ($uflg);
	$v .= "$tmparr[8]," if ($vflg);
	$temp .= "$tmparr[9]," if ($tflg);
	$psal .= "$tmparr[10]," if ($aflg);
	$pres .= "$tmparr[11]," if ($pflg);
	$norec++;
    }
    $stop_date = $timestr;
    $timeline =~s/,$//;
    $speed =~s/,$// if ($sflg);
    $direction =~s/,$// if ($dflg);
    $u =~s/,$// if ($uflg);
    $v =~s/,$// if ($vflg);
    $pres =~s/,$// if ($pflg);
    $temp =~s/,$// if ($tflg);
    $psal =~s/,$// if ($aflg);

    ########################################################### 
    # Then this information is substituted into the CDL template

    # First remove variables not supported
    if ($sflg == 0) {
	@tmparr = grep(!/speed/,@cdlout);
	@cdlout = @tmparr;
    }
    unless ($dflg) {
	@tmparr = grep !/direction/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($uflg) {
	@tmparr = grep !/ucomp/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($vflg) {
	@tmparr = grep !/vcomp/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($tflg) {
	@tmparr = grep !/temp/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($pflg) {
	@tmparr = grep !/pres/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($aflg) {
	@tmparr = grep !/psal/,@cdlout;
	@cdlout = @tmparr;
    }

    s/\+nlevels/$nlevels/ for (@cdlout);
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+start_date/$start_date/ for (@cdlout);
    s/\+stop_date/$stop_date/ for (@cdlout);
    s/\+depth/$depth/ for (@cdlout);
    s/\+time/$timeline/ for (@cdlout);
    if ($pflg) {
	s/\+pres/$pres/ for (@cdlout);
    }
    if ($sflg) {
	s/\+speed/$speed/ for (@cdlout);
    }
    if ($dflg) { 
	s/\+direction/$direction/ for (@cdlout);
    }
    if ($uflg) { 
	s/\+ucomp/$u/ for (@cdlout);
    }
    if ($vflg) { 
	s/\+vcomp/$v/ for (@cdlout);
    }
    if ($tflg) {
	s/\+temp/$temp/ for (@cdlout);
    }
    if ($aflg) { 
	s/\+psal/$psal/ for (@cdlout);
    }

    return(@cdlout);
}

#
# Read and convert the level2 ITP-format used by Woods Hole Institute for ice
# tethered platforms.
#
sub create_itp_cdl {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr,$timeunixref);
    my(@mytmp,$pname,$hours,$hourref,$timeofdata,$lat,$lon,$nvalues);
    my($nlat,$slat,$wlon,$elon);
    my($myvariables,$myunits,$thickness,$altitude,$myurl);
    my($myhistory,$start_date,$stop_date,$institution,$contact,$myarea);
    my($conventions,$distribution_statement,$project_name,$productname);
    my($topiccategory,$mykeywords,$mygcmdkeywords,$activity_type,$PI_name);
    my($line,$norec,$misvalin,$misvalout);
    my($itpid,$profileid,$vessel);
    my($myyear,$myday,$pressure,$temperature,$salinity);

    ###########################################################
    # Do some initialization
    $misvalin = "Nan";
    $misvalout = -999.;
    $title = "";
    $abstract = "The Ice-Tethered Profiler data were collected and made available by the Ice-Tethered Profiler Program based at the Woods Hole Oceanographic Institution (http://www.whoi.edu/itp). ITP data are similar to CTD data, but are collected from buoys frozen in the sea ice.";
    $productname = "ITP profile";
    $myarea = "Arctic Ocean";
    $topiccategory = "oceans";
    $mykeywords = "pressure,temperature,salinity";
    $mygcmdkeywords = "";
    $activity_type = "Ice station";
    $vessel = "";
    $myhistory = "";
    $distribution_statement = "Free";
    $conventions = "CF-1.0";
    $PI_name = "";
    $institution = "Woods Hole Oceanographic Institute";
    $contact = "itp\@whoi.edu";
    $myurl = "http://www.whoi.edu/itp/";
    $project_name = "Damocles";
    $start_date = "";
    $stop_date = "";


    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    # File records
    @mytmp = @$txtref;
    s/\ +/ /g for (@mytmp);
    s/^\ |\ $// for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	if ($norec == 0){
	    $line =~ s/^\%//;
	    @tmparr = (split /,/,$line);
	    $itpid = $tmparr[0];
	    $itpid =~ s/\D*//;
	    $profileid = (split /:/,$tmparr[1])[0];
	    $profileid =~ s/\D*//;
	    $norec++;
	    next;
	}
	if ($norec == 1) {
	    $line =~ s/^\ +/ /g;
	    @tmparr = (split / /,$line);
	    $myyear = $tmparr[0];
	    $myday = $tmparr[1];
	    $timeunix = year_and_day2epoch($myyear,$myday);
	    @timearr = gmtime($timeunix);
	    $timestr= strftime("%F %T UTC",@timearr);
	    $lon = $tmparr[2];
	    $lat = $tmparr[3];
	    $nvalues = $tmparr[4];
	    $norec++;
	    next;
	}
	if ($line =~ m/^\%/){
	    $norec++;
	    next;
	}
	@tmparr = split / /,$line;
	$myyear = $tmparr[0];
	$myday = $tmparr[1];
	$timeofdata .= year_and_day2epoch($myyear,$myday).",";
	$pressure .= $tmparr[2].",";
	$temperature .= $tmparr[3].",";
	$salinity .= $tmparr[4].",";
	$norec++;
    }
    warn "Data records: nvalues ($nvalues) and norec ($norec-4) differ\n" if ($nvalues != $norec-4);
    $timeofdata =~ s/,$//;
    $lat =~ s/,$//;
    $lon =~ s/,$//;
    $pressure =~ s/,$//;
    $salinity =~ s/,$//;
    $temperature =~ s/,$//;

    $title .= sprintf "ITP %02d Profile %06d",$itpid,$profileid;
    $vessel = sprintf "ITP %02d",$itpid;
    $myhistory = sprintf "%s creation",strftime("%F",gmtime(time));

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+title/$title/ for (@cdlout);
    s/\+abstract/$abstract/ for (@cdlout);
    s/\+topic/$topiccategory/ for (@cdlout);
    s/\+keyw/$mykeywords/ for (@cdlout);
    s/\+gcmdkeyw/$mygcmdkeywords/ for (@cdlout);
    s/\+area/$myarea/ for (@cdlout);
    s/\+inst/$institution/ for (@cdlout);
    s/\+url/$myurl/ for (@cdlout);
    s/\+piname/$PI_name/ for (@cdlout);
    s/\+email/$contact/ for (@cdlout);
    s/\+distribution/$distribution_statement/ for (@cdlout);
    s/\+pname/$productname/ for (@cdlout);
    s/\+projectname/$project_name/ for (@cdlout);
    s/\+activity/$activity_type/ for (@cdlout);
    s/\+history/$myhistory/ for (@cdlout);
    s/\+vessel/$vessel/ for (@cdlout);
    s/\+nlat/$lat/ for (@cdlout);
    s/\+slat/$lat/ for (@cdlout);
    s/\+wlon/$lon/ for (@cdlout);
    s/\+elon/$lon/ for (@cdlout);
    s/\+start_date/$timestr/ for (@cdlout);
    s/\+stop_date/$timestr/ for (@cdlout);
    s/\+nvalues/$nvalues/ for (@cdlout);
    s/\+time/$timeofdata/ for (@cdlout);
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+temperature/$temperature/ for (@cdlout);
    s/\+salinity/$salinity/ for (@cdlout);
    s/\+pressure/$pressure/ for (@cdlout);

    return(@cdlout);
}

#
# Read and convert a specific trajectory format used by AWI for ice
# thickness measurements from helicopter.
#
sub create_trajectory_cdl_awiem {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr_start,$timestr_end,$timeunixref);
    my(@mytmp,$pname,$hours,$hourref,$timeofdata,$lat,$lon,$nvalues);
    my($nlat,$slat,$wlon,$elon);
    my($myvariables,$myunits,$thickness,$altitude,$myurl);
    my($myhistory,$start_date,$stop_date,$institution,$contact,$myarea);
    my($conventions,$distribution_statement,$project_name,$productname);
    my($topiccategory,$mykeywords,$mygcmdkeywords,$activity_type,$PI_name);
    my($line,$norec,$misvalin,$misvalout);

    ###########################################################
    # Do some initialization
    $misvalin = "Nan";
    $misvalout = -999.;
    $title = "";
    $abstract = "";
    $productname = "";
    $myarea = "";
    $topiccategory = "";
    $mykeywords = "";
    $mygcmdkeywords = "";
    $activity_type = "";
    $myhistory = "";
    $distribution_statement = "";
    $conventions = "";
    $PI_name = "";
    $institution = "";
    $contact = "";
    $myurl = "";
    $project_name = "";
    $start_date = "";
    $stop_date = "";


    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data
    # stream

    # title
    @mytmp = grep /^# title: /,@$txtref;
    unless ($#mytmp == -1) {
	$title = (split /:/,$mytmp[0])[1];
	$title =~ s/[\n\r]//g;
	$title =~ s/^\ //;
    }

    # abstract
    @mytmp = grep /^# abstract: /,@$txtref;
    unless ($#mytmp == -1) {
	$abstract = (split /:/,$mytmp[0])[1];
	$abstract =~ s/[\n\r]//g;
	$abstract =~ s/^\ //;
    }

    # topiccatergory
    @mytmp = grep /^# topiccategory: /,@$txtref;
    unless ($#mytmp == -1) {
	$topiccategory = (split /:/,$mytmp[0])[1];
	$topiccategory =~ s/[\n\r]//g;
	$topiccategory =~ s/,/ /g;
	$topiccategory =~ s/^\s//g;
    }

    # keywords
    @mytmp = grep /^# keywords: /,@$txtref;
    unless ($#mytmp == -1) {
	$mykeywords = (split /:/,$mytmp[0])[1];
	$mykeywords =~ s/[\n\r]//g;
	$mykeywords =~ s/,/ /g;
    }

    # gcmd_keywords
    @mytmp = grep /^# gcmd_keywords: /,@$txtref;
    unless ($#mytmp == -1) {
	$mygcmdkeywords = (split /:/,$mytmp[0])[1];
	$mygcmdkeywords =~ s/[\n\r]//g;
	$mygcmdkeywords =~ s/,/ /g;
    }

    # activity_type
    @mytmp = grep /^# activity_type: /,@$txtref;
    unless ($#mytmp == -1) {
	$activity_type = (split /:/,$mytmp[0])[1];
	$activity_type =~ s/[\n\r]//g;
	$activity_type =~ s/^\s//g;
    }

    # Conventions
    @mytmp = grep /^# Conventions: /,@$txtref;
    unless ($#mytmp == -1) {
	$conventions = (split /:/,$mytmp[0])[1];
	$conventions =~ s/[\n\r]//g;
    }

    # product_name
    @mytmp = grep /^# product_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$productname = (split /:/,$mytmp[0])[1];
	$productname =~ s/[\n\r]//g;
	$productname =~ s/^\s//g;
    }

    # history
    @mytmp = grep /^# history: /,@$txtref;
    unless ($#mytmp == -1) {
	$myhistory = (split /:/,$mytmp[0])[1];
	$myhistory =~ s/[\n\r]//g;
	$myhistory =~ s/,/\n/g;
    }

    # area
    @mytmp = grep /^# area: /,@$txtref;
    unless ($#mytmp == -1) {
	$myarea = (split /:/,$mytmp[0])[1];
	$myarea =~ s/[\n\r]//g;
	$myarea =~ s/^\s//g;
    }

    # northernmost_latitude
    @mytmp = grep /^# northernmost_latitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$nlat = (split /:/,$mytmp[0])[1];
	$nlat =~ s/^ //;
	$nlat =~ s/[\n\r]//g;
    }

    # southernmost_latitude
    @mytmp = grep /^# southernmost_latitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$slat = (split /:/,$mytmp[0])[1];
	$slat =~ s/^ //;
	$slat =~ s/[\n\r]//g;
    }

    # westernmost_longitude
    @mytmp = grep /^# westernmost_longitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$wlon = (split /:/,$mytmp[0])[1];
	$wlon =~ s/^ //;
	$wlon =~ s/[\n\r]//g;
    }

    # easternmost_longitude
    @mytmp = grep /^# easternmost_longitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$elon = (split /:/,$mytmp[0])[1];
	$elon =~ s/^ //;
	$elon =~ s/[\n\r]//g;
    }

    # start_date
    @mytmp = grep /^# start_date: /,@$txtref;
    unless ($#mytmp == -1) {
	$start_date = (split /:/,$mytmp[0])[1];
	$start_date =~ s/[\n\r]//g;
	$timeunix = str2time($start_date,"UTC");
	$timeunixref = $timeunix;
	@timearr = gmtime($timeunix);
	$timestr_start = strftime("%F %T UTC",@timearr);
    }

    # stop_date
    @mytmp = grep /^# stop_date: /,@$txtref;
    unless ($#mytmp == -1) {
	$stop_date = (split /:/,$mytmp[0])[1];
	$stop_date =~ s/[\r\n]//g;
	$timeunix = str2time($stop_date,"UTC");
	@timearr = gmtime($timeunix);
	$timestr_end = strftime("%F %T UTC",@timearr);
    }

    # institution
    @mytmp = grep /^# institution: /,@$txtref;
    unless ($#mytmp == -1) {
	$institution = (split /:/,$mytmp[0])[1];
	$institution =~ s/[\s]//g;
	$institution =~ s/^\s//g;
    }

    # PI_name
    @mytmp = grep /^# PI_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$PI_name = (split /:/,$mytmp[0])[1];
	$PI_name =~ s/[\n\r]//g;
	$PI_name =~ s/^\s//g;
    }

    # contact
    @mytmp = grep /^# contact: /,@$txtref;
    unless ($#mytmp == -1) {
	$contact = (split /:/,$mytmp[0])[1];
	$contact =~ s/[\s]//g;
    }

    # distribution_statement
    @mytmp = grep /^# distribution_statement: /,@$txtref;
    unless ($#mytmp == -1) {
	$distribution_statement = (split /:/,$mytmp[0])[1];
	$distribution_statement =~ s/[\s]//g;
    }

    # project_name
    @mytmp = grep /^# project_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$project_name = (split /:/,$mytmp[0])[1];
	$project_name =~ s/[\s]//g;
    }

    # variables
    @mytmp = grep /^# variables: /,@$txtref;
    unless ($#mytmp == -1) {
	$myvariables = (split /:/,$mytmp[0])[1];
	$myvariables =~ s/[\s]//g;
	die "Incorrect variables for this format specification" unless ($myvariables eq "latitude,longitude,time,thickness,altitude");
    }

    # units
    @mytmp = grep /^# units: /,@$txtref;
    unless ($#mytmp == -1) {
	$myunits = (split /:/,$mytmp[0])[1];
	$myunits =~ s/[\s]//g;
	die "Incorrect unit specification for this format" unless ($myunits eq "degrees_North,degrees_East,hours,meter,meter");
    }

    # Nvalues
    @mytmp = grep /^\# number of observations: /,@$txtref;
    unless ($#mytmp == -1) {
	$nvalues = (split /:/,$mytmp[0])[1];
	$nvalues =~ s/[\s\n\r]//g;
    }

    # Data records
    @mytmp = grep /^\s/,@$txtref;
    s/\ +/ /g for (@mytmp);
    s/^\ |\ $// for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	next if (length($line) == 0);
	@tmparr = split / /,$line;
	$lat .= "$tmparr[0],";
	$lon .= "$tmparr[1],";
	$hours = $tmparr[2];
	$hourref = int($hours) if ($norec == 0);
	$timeunix = int(($hours-$hourref)*60*60);
	$timeunix += $timeunixref;
	$timeofdata .= "$timeunix,"; 
	$thickness .= "$tmparr[3],";
	$altitude .= "$tmparr[4],";
	$norec++;
    }
    warn "Data records: nvalues ($nvalues) and norec ($norec) differ\n" if ($nvalues != $norec);
    $timeofdata =~ s/,$//;
    $lat =~ s/,$//;
    $lon =~ s/,$//;
    $hours =~ s/,$//;
    $thickness =~ s/,$//;
    $thickness =~ s/$misvalin/$misvalout/g;
    $altitude =~ s/,$//;
    $altitude =~ s/$misvalin/$misvalout/g;

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+title/$title/ for (@cdlout);
    s/\+abstract/$abstract/ for (@cdlout);
    s/\+topic/$topiccategory/ for (@cdlout);
    s/\+keyw/$mykeywords/ for (@cdlout);
    s/\+area/$myarea/ for (@cdlout);
    s/\+inst/$institution/ for (@cdlout);
    s/\+url/$url/ for (@cdlout);
    s/\+piname/$PI_name/ for (@cdlout);
    s/\+email/$contact/ for (@cdlout);
    s/\+distribution_statement/$distribution_statement/ for (@cdlout);
    s/\+pname/$productname/ for (@cdlout);
    s/\+projectname/$project_name/ for (@cdlout);
    s/\+activity/$activity_type/ for (@cdlout);
    s/\+history/$myhistory/ for (@cdlout);
    s/\+nlat/$nlat/ for (@cdlout);
    s/\+slat/$slat/ for (@cdlout);
    s/\+wlon/$wlon/ for (@cdlout);
    s/\+elon/$elon/ for (@cdlout);
    s/\+start_date/$timestr_start/ for (@cdlout);
    s/\+stop_date/$timestr_end/ for (@cdlout);
    s/\+time/$timeofdata/ for (@cdlout);
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+thickness/$thickness/ for (@cdlout);
    s/\+altitude/$altitude/ for (@cdlout);

    return(@cdlout);
}

# Dump data to CDL
sub write_file($@) {

    my($filename,@text) = @_;
    my($line);

    open FH, ">$filename" or die " Could not open file $filename\n";
    foreach $line (@text) {
	print FH "$line";
    }
    close FH;

    return(1);
}

