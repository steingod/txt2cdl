#!/usr/bin/perl -w
#
# NAME:
# txt2cdl
#
# PURPOSE:
# To convert various ASCII files to CDL format for subsequent conversion
# to netCDF using ncgen. See function usage for details on supported file
# formats.
#
# REQUIREMENTS:
# o Getopt::Std;
# o Time::Local;
# o Date::Parse; 
# o POSIX qw(strftime);
# o Text::Wrap;
#
# INPUT:
# See function usage 
#
# OUTPUT:
# See function usage 
#
# NOTES:
# NA
#
# BUGS:
# Input checking is yet not properly imeplemented, but baseline
# functionality for the formats supported are implemented.
#
# AUTHOR:
# Øystein Godøy, METNO/FOU, 09.05.2007 
#
# MODIFIED:
# Øystein Godøy, METNO/FOU, 11.05.2007
# Øystein Godøy, METNO/FOU, 11.03.2008: Added support for WOCE CTD-format.
# Øystein Godøy, METNO/FOU, 17.10.2008: Added support for AWI Helicopter
# Ice Thickness measurements.
# Øystein Godøy, METNO/FOU, 19.10.2008: Adding ITP conversion
# Øystein Godøy, METNO/FOU, 24.10.2008: Adding conversion of radiation
# flux data from Bear Island.
# Øystein Godøy, METNO/FOU, 25.10.2008: Bug fix ITP-handling.
# Øystein Godøy, METNO/FOU, 30.10.2008: Bug fix on AWIEM-handling.
# Øystein Godøy, METNO/FOU, 26.11.2008: Added ASCII-format for moorings.
# Øystein Godøy, METNO/FOU, 27.12.2008: Added quality control of DLI
# measurements due to technical trouble at Jan Mayen and Bear Island.
# Minute values should not exceed 200 W/m^2, be careful in the future. Did
# also add warning when processing radiative flux measurements...
#
# CVS_ID:
# $Id: txt2cdl,v 1.24 2008-12-27 17:51:41 steingod Exp $
#  

########################################################### 
# Requirements
use strict;
use Getopt::Std;
use Time::Local;
use Text::Wrap;
use Date::Parse;
#use Date::Format;
use POSIX qw(strftime);
use vars qw($opt_i $opt_o $opt_a $opt_m $opt_t $opt_e $opt_k $opt_v $opt_r $opt_c $opt_g $opt_b $opt_p $opt_h $opt_u $opt_f $opt_n $opt_q);

########################################################### 
# Prototypes
sub usage;
sub year_and_day2epoch;
sub read_file;
sub create_ctd_cdl_woce;
sub create_ctd_cdl_seabirdnfh;
sub create_itp_cdl;
sub create_mooring_cdl_mooringgfi;
sub create_mooring_cdl_ascii;
sub create_trajectory_cdl_awiem;
sub create_timeseries_cdl_radflux;
sub write_file;

my($ifn,$ofn,@text,$fileformat,$cdlhead);
my($template_file, @template, $line, @cdloutput);
my($piname,$title,$topic,$keyw,$email,$area,$inst,$vessel);
my($distribution,$abstract,$history,$url,$pname,$qual);

########################################################### 
# Option decoding
usage if !getopts('i:o:a:m:t:e:k:r:g:v:c:g:p:b:h:u:f:n:q:');
usage if ((! $opt_i) || (!$opt_o) || (!$opt_f) || (!$opt_m));
$ifn = $opt_i;
$ofn = $opt_o;
if ($opt_f) {
    $fileformat = $opt_f;
} else {
    $fileformat = "";
}
if ($opt_g) {
    $inst = $opt_g;
} else {
    $inst = "";
}
if ($opt_a) {
    $piname = $opt_a;
} else {
    $piname = "";
}
if ($opt_t) {
    $title = $opt_t;
} else {
    $title = "";
}
if ($opt_p) {
    $topic = $opt_p;
} else {
    $topic = "";
}
if ($opt_k) {
    $keyw = $opt_k;
} else {
    $keyw = "";
}
if ($opt_e) {
    $email = $opt_e;
} else {
    $email = "";
}
if ($opt_r) {
    $area = $opt_r;
} else {
    $area = "";
}
if ($opt_b) {
    $abstract = $opt_b;
} else {
    $abstract = "";
}
if ($opt_n) {
    $pname = $opt_n;
} else {
    $pname = "";
}
if ($opt_v) {
    $vessel = $opt_v;
} else {
    $vessel = "";
}
if ($opt_c) {
    $distribution = $opt_c;
} else {
    $distribution = "Free";
}
if ($opt_u) {
    $url = $opt_u;
} else {
    $url = "";
}
if ($opt_h) {
    $history = $opt_h;
} else {
    $history = strftime("%F",gmtime(time))." Created";
}
if ($opt_m) {
    $template_file = $opt_m;
} else {
    $template_file = "";
}
if ($opt_q) {
    $qual = $opt_q;
} else {
    $qual = "Unknown quality";
}

###########################################################
# Read template file
print "\n";
print " Reading file: $template_file\n";
@template = read_file($template_file);

########################################################### 
# Read input data
print "\n";
print " Reading file: $ifn\n";
@text = read_file($ifn);

###########################################################
# Extract information from input file and create CDL structure
print "\n";
print " Converting data to CDL\n";
if ($fileformat eq "seabirdnfh") {
    @cdloutput = create_ctd_cdl_seabirdnfh(\@template,\@text);
} elsif ($fileformat eq "wocectd") {
    @cdloutput = create_ctd_cdl_woce(\@template,\@text);
} elsif ($fileformat eq "itp") {
    @cdloutput = create_itp_cdl(\@template,\@text);
} elsif ($fileformat eq "mooring") {
    @cdloutput = create_mooring_cdl_ascii(\@template,\@text);
} elsif ($fileformat eq "mooringgfi") {
    @cdloutput = create_mooring_cdl_mooringgfi(\@template,\@text);
} elsif ($fileformat eq "awiem") {
    @cdloutput = create_trajectory_cdl_awiem(\@template,\@text);
} elsif ($fileformat eq "metnoradflux") {
    warn "DLI measurements are truncated at 200 W/m^2!!";
    @cdloutput = create_timeseries_cdl_radflux(\@template,\@text);
} else {
    die "Fileformat ($fileformat) is not supported\n";
}

########################################################### 
# Add header information
unless ($fileformat eq "awiem" or $fileformat eq "metnoradflux" or
$fileformat eq "mooring") {
    s/\+title/$title/ for (@cdloutput);
    s/\+abstract/$abstract/ for (@cdloutput);
    s/\+topic/$topic/ for (@cdloutput);
    s/\+keyw/$keyw/ for (@cdloutput);
    s/\+area/$area/ for (@cdloutput);
    s/\+inst/$inst/ for (@cdloutput);
    s/\+piname/$piname/ for (@cdloutput);
    s/\+email/$email/ for (@cdloutput);
    s/\+distribution/$distribution/ for (@cdloutput);
    s/\+vessel/$vessel/ for (@cdloutput);
    s/\+pname/$pname/ for (@cdloutput);
    s/\+history/$history/ for (@cdloutput);
    s/\+url/$url/ for (@cdloutput);
    s/\+qual/$qual/ for (@cdloutput);
}

########################################################### 
# Create output file
$cdlhead = $ofn;
$cdlhead =~ s/(\.cdl)|(\.txt)|(\.dat)//;
$cdloutput[0] =~ s/template_\w+ /$cdlhead /;
print "\n";
print " Writing file: $ofn\n";
die " Could not write output file\n" if (! write_file($ofn, @cdloutput));
print "\n";

exit;

########################################################### 
#
#
########################################################### 
# Function definitions
########################################################### 
#
#
########################################################### 

#
# Usage description
#
sub usage() {
    $Text::Wrap::columns = 74;

    my $text = "This software transforms various ASCII formats into CDL files which can be converted to netCDF by ncgen. The file formats supported may change.";
    my $formats = 
    "o WOCE CTD ASCII format - (format=wocectd)\n".
    "o SeaBird ASCII format by NFH, Tromsø, Norway - (format=seabirdnfh)\n".
    "o Current mooring format by GFI, Bergen, Norway - (format=mooringgfi)\n".
    "o Current mooring format in ASCII - (format=mooring)\n".
    "o Helicopter trajectory of ice thickness by AWI, Germany - (format=awiem)\n".
    "o ITP-data from Woods Hole, daily updates - (format=itp)\n".
    "o METNO radiative flux measurements, continous stream - (format=metnoradflux)";
    my $author = "Øystein Godøy, METNO/FOU, 24.10.2008";

    print "\n";
    print wrap("","\t","$0 -i <infile> -o <outfile> -f <format> -m <template> [-a <author> -e <email> -g <institution> -u <url> -t <title> -b <abstract> -v <platform> -n <product_name> -p <topic> -k <keywords> -r <area_covered> -c <distribution> -h <history> -q <quality>]\n");
    print "\n";
    print "\t<infile>: Some supported ASCII file,\n".
	"\t\tif a directory it tries to process contents\n";
    print "\t<outfile>: CDL file according to CF standard,\n".
	"\t\tif infile is a directory this should be a directory\n";
    print "\t<format>: Input file format, se below\n";
    print "\t<template>: CDL template file according to CF standard, usually in etc\n";
    print "\t<author>: PI name\n";
    print "\t<email>: PI or responsible person email address\n";
    print "\t<institution>: Name of institution\n";
    print "\t<url>: URL of institution/PI\n";
    print "\t<title>: Title of dataset\n";
    print "\t<abstract>: Short description of data\n";
    print "\t<platform>: E.g. name of the research vessel used\n";
    print "\t<product_name>: Product name\n";
    print "\t<topic>: Topic category of dataset (predefined list)\n";
    print "\t<keywords>: Keywords of dataset (predefined list)\n";
    print "\t<area_covered>: Area of observation (predefined list)\n";
    print "\t<distribution>: Data distribution statement (free, restricted)\n";
    print "\t<history>: Short description of data history\n";
    print "\t<quality>: \"Unknown quality\", \"Excellent\",\"Fair\",\"Questionable\"\n";
    print "\n";
    print wrap("\t", "\t", $text);
    print "\n\n";
    print wrap("\t", "\t", $formats);
    print "\n\n";
    print "\t$author\n";
    print "\n";
    exit;
}

#
# Convert year and decimal days to epoch time
#
sub year_and_day2epoch($$) {
    my($myyear,$myday) = @_;
    my($timeepoch,$timestr);

    $timestr = sprintf "%4d-01-01 00:00 GMT", $myyear;

    #print "$myyear $myday ";

    $timeepoch = str2time($timestr);
    $myday *= (24*3600.);

    $timeepoch += int($myday);

    #print "$myday $timeepoch\n";

    return($timeepoch);
}

#
# Read a file
#
sub read_file($) {

    my($filename) = @_;
    my(@text);

    open FH, "<$filename" or die " Could not open file $filename\n";
    @text = <FH>;
    close FH;

    return(@text);
}

#
# Dump CDL code
#
sub write_file($@) {

    my($filename,@text) = @_;
    my($line);

    open FH, ">$filename" or die " Could not open file $filename\n";
    foreach $line (@text) {
	print FH "$line";
    }
    close FH;

    return(1);
}

#
# Decode and convert WOCE ASCII CTD files
#
sub create_ctd_cdl_woce {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my($tmpstr, $yy, $mm, $dd, $hh, $ii);
    my(@timearr,$timeunix, $timestr);
    my(@mytmp,$pname,$vessel,$lat,$lon,$nvalues);
    my($pres,$temp,$psal);
    my($pres_flg,$temp_flg,$psal_flg);
    my($line,$norec);

    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data

    # Sensor name
    $pname = $txtref->[0];
    $pname =~ s/[\n\r]//;

    # Time
    @mytmp = grep /^DATE = /,@$txtref;
    chop($mytmp[0]);
    $mytmp[0] =~ s/DATE = //g;
    $yy = substr $mytmp[0],0,4;
    $mm = substr $mytmp[0],4,2;
    $dd = substr $mytmp[0],6,2;
    @mytmp = grep /^TIME = /,@$txtref;
    chop($mytmp[0]);
    $mytmp[0] =~ s/TIME = //g;
    $hh = substr $mytmp[0],0,2;
    $ii = substr $mytmp[0],2,2;
    $timestr = sprintf("%4d-%02d-%02d %02d:%02d:%02d UTC", 
	    $yy, $mm, $dd, $hh, $ii, 0);
    $timeunix = str2time($timestr);

    # Latitude
    @mytmp = grep /^LATITUDE = /,@$txtref;
    $lat = substr((split /=/,$mytmp[0])[1],0,-1);

    # Longitude
    @mytmp = grep /^LONGITUDE = /,@$txtref;
    $lon = substr((split /=/,$mytmp[0])[1],0,-1);

    # Data records
    @mytmp = grep /^\ |^[0-9]/,@$txtref;
    s/^(\s+)// for (@mytmp);
    s/\s+/ /g for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	@tmparr = split /,/,$line;
	$pres .= "$tmparr[0],";
	$pres_flg .= "$tmparr[1],";
	$temp .= "$tmparr[2],";
	$temp_flg .= "$tmparr[3],";
	$psal .= "$tmparr[4],";
	$psal_flg .= "$tmparr[5],";
	$norec++;
    }
    print "$norec pressure levels found in file, abort if incorrect...\n";
    $nvalues = $norec;
    $pres =~s/,$//;
    $temp =~s/,$//;
    $psal =~s/,$//;

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+nvalues/$nvalues/ for (@cdlout);
    s/\+pname/$pname/ for (@cdlout); # Actually a global variabel
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+time/$timeunix/ for (@cdlout);
    s/\+YYYY\-MM\-DD HH\:MM\:SS UTC/$timestr/ for (@cdlout);
    s/\+pres/$pres/ for (@cdlout);
    s/\+temp/$temp/ for (@cdlout);
    s/\+psal/$psal/ for (@cdlout);

    return(@cdlout);
}

#
# Decode and convert a specific SEABIRD format used by NFH/Tromsø
#
sub create_ctd_cdl_seabirdnfh {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr);
    my(@mytmp,$pname,$vessel,$lat,$lon,$nvalues);
    my($pres,$temp,$cond,$psal);
    my($line,$norec);

    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data
    # stream

    # Sensor name
    $pname = $txtref->[0];
    $pname =~ s/(^(\* ))|://g;
    $pname =~ s/[\n\r]//g;

    # Time
    @mytmp = grep /^\* NMEA UTC \(Time\) = /,@$txtref;
    $timestr = (split /=/,$mytmp[0])[1];
    $timestr =~ s/[\n\r]//g;
    $timestr =~ s/\s+/ /g;
    $timeunix = str2time($timestr);
    @timearr = gmtime($timeunix);
    $timestr = strftime("%F %T UTC",@timearr);

    # Vessel
    @mytmp = grep /^\*\* Ship: /,@$txtref;
    $vessel = (split /:/,$mytmp[0])[1];
    $vessel =~ s/^(\s+)//;
    $vessel =~ s/[\n\r]//g;

    # Latitude
    @mytmp = grep /^\* NMEA Latitude = /,@$txtref;
    $lat = (split /=/,$mytmp[0])[1];
    $lat =~ s/^ //;
    @mytmp = split / /,$lat,3;
    $lat = $mytmp[0]+($mytmp[1]/60.);
    $mytmp[2] =~ s/[\n\r]//g;
    $lat *= (-1.) if ($mytmp[2] eq "S");

    # Longitude
    @mytmp = grep /^\* NMEA Longitude = /,@$txtref;
    $lon = (split /=/,$mytmp[0])[1];
    $lon =~ s/^ //;
    @mytmp = split / /,$lon,3;
    $lon = $mytmp[0]+($mytmp[1]/60.);
    $mytmp[2] =~ s/[\n\r]//g;
    $lon *= (-1.) if ($mytmp[2] eq "W");

    # Nvalues
    @mytmp = grep /^\# nvalues = /,@$txtref;
    $nvalues = (split /=/,$mytmp[0])[1];
    $nvalues =~ s/[\s\n\r]//g;

    # Data records
    @mytmp = grep /^\s/,@$txtref;
    s/^(\s+)// for (@mytmp);
    s/\s+/ /g for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	@tmparr = split / /,$line;
	$pres .= "$tmparr[1],";
	$temp .= "$tmparr[2],";
	$cond .= "$tmparr[3],";
	$psal .= "$tmparr[4],";
	$norec++;
    }
    warn "Data records: nvalues ($nvalues) and norec ($norec) differ\n" if ($nvalues != $norec);
    $pres =~s/,$//;
    $temp =~s/,$//;
    $cond =~s/,$//;
    $psal =~s/,$//;

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+nvalues/$nvalues/ for (@cdlout);
    s/\+pname/$pname/ for (@cdlout); # Actually a global variabel
    s/\+vessel/$vessel/ for (@cdlout); # Actually a global variabel
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+time/$timeunix/ for (@cdlout);
    s/\+YYYY\-MM\-DD HH\:MM\:SS UTC/$timestr/ for (@cdlout);
    s/\+pres/$pres/ for (@cdlout);
    s/\+temp/$temp/ for (@cdlout);
    s/\+cond/$cond/ for (@cdlout);
    s/\+psal/$psal/ for (@cdlout);

    return(@cdlout);
}

#
# Decode and convert the mooring format of GFI/UiB
#
sub create_mooring_cdl_mooringgfi {

    my(@cdlout,@tmparr,$tmpstr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr,$timeline);
    my(@mytmp,$pname,$vessel,$lat,$lon,$nvalues);
    my($speed,$directiontemp,$ucomp,$vcomp,$temp,$psal,$pres);
    my($line,$norec,$depth,$instrid,$u,$v,$nlevels,$direction);
    my($start_date,$stop_date,$nparam,$params);
    my($sflg,$dflg,$uflg,$vflg,$tflg,$pflg,$aflg);

    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data
    # stream

    # Header begins with %
    @mytmp = grep /^\%/,@$txtref;

    s/\%// for (@mytmp);
    @tmparr = split /=/,$mytmp[0];

    # Instrument identification
    $instrid = $tmparr[0]; 
    $instrid =~ s/ N.*$//;

    # Parameters in the file, code is as following
    # F - speed, A - direction, U - u component, V - v component,
    # T - temperature, P - pressure, S - salinity
    $params = $tmparr[1];
    $params =~s/^(\s+[0-9]+\s)//g;
    $tmpstr = (split / +/,$params)[0];
    $params = $tmpstr;
    $sflg = ($params =~ /F/)?1:0;
    $dflg = ($params =~ /A/)?1:0;
    $uflg = ($params =~ /U/)?1:0;
    $vflg = ($params =~ /V/)?1:0;
    $tflg = ($params =~ /T/)?1:0;
    $pflg = ($params =~ /P/)?1:0;
    $aflg = ($params =~ /S/)?1:0;

    # Number of datarecords
    $nvalues = $tmparr[1]; 
    $nvalues =~ s/\s|[a-zA-Z]//g;

    # Number of levels
    $nlevels = 1;

    # Date of deployment
    $timestr = sprintf("%4d-%02d-%02d %02d:%02d:%02d UTC",
	    (2000+substr($tmparr[3],0,2)),
	    substr($tmparr[3],2,2),
	    substr($tmparr[3],4,2),
	    substr($tmparr[3],7,2),
	    substr($tmparr[3],9,2),
	    0);
    $start_date = $timestr;

    # Depth
    $depth = $tmparr[4]; 
    $depth =~ s/\s|[a-zA-Z]//g;

    # Latitude
    $tmpstr = $tmparr[5];
    $lat = substr($tmpstr,1,2)+
	(substr($tmpstr,3,2)+(substr($tmpstr,5,2)/100.))/60.;
    $lat *= -1. if ($tmpstr =~ /S/);

    # Longitude
    $lon= substr($tmpstr,8,3)+
	(substr($tmpstr,11,2)+(substr($tmpstr,13,2)/100.))/60.;
    $lon *= -1. if ($tmpstr =~ /W/);

    # Data records
    @mytmp = grep !/(^\%)/,@$txtref;
    s/^(\s+)// for (@mytmp);
    s/\s+/ /g for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	@tmparr = split / /,$line;
	$timearr[0] = 0;
	$timearr[1] = $tmparr[4];
	$timearr[2] = $tmparr[3];
	$timearr[3] = $tmparr[2];
	$timearr[4] = $tmparr[1]-1;
	$timearr[5] = $tmparr[0]+100;
	$timestr = strftime("%F %T UTC",@timearr);
	$timeunix = timegm(@timearr);
	$timeline .= "$timeunix,";
	$speed .= "$tmparr[5]," if ($sflg);
	$direction .= "$tmparr[6]," if ($dflg);
	$u .= "$tmparr[7]," if ($uflg);
	$v .= "$tmparr[8]," if ($vflg);
	$temp .= "$tmparr[9]," if ($tflg);
	$psal .= "$tmparr[10]," if ($aflg);
	$pres .= "$tmparr[11]," if ($pflg);
	$norec++;
    }
    $stop_date = $timestr;
    $timeline =~s/,$//;
    $speed =~s/,$// if ($sflg);
    $direction =~s/,$// if ($dflg);
    $u =~s/,$// if ($uflg);
    $v =~s/,$// if ($vflg);
    $pres =~s/,$// if ($pflg);
    $temp =~s/,$// if ($tflg);
    $psal =~s/,$// if ($aflg);

    ########################################################### 
    # Then this information is substituted into the CDL template

    # First remove variables not supported
    if ($sflg == 0) {
	@tmparr = grep(!/speed/,@cdlout);
	@cdlout = @tmparr;
    }
    unless ($dflg) {
	@tmparr = grep !/direction/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($uflg) {
	@tmparr = grep !/ucomp/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($vflg) {
	@tmparr = grep !/vcomp/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($tflg) {
	@tmparr = grep !/temp/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($pflg) {
	@tmparr = grep !/pres/,@cdlout;
	@cdlout = @tmparr;
    }
    unless ($aflg) {
	@tmparr = grep !/psal/,@cdlout;
	@cdlout = @tmparr;
    }

    s/\+nlevels/$nlevels/ for (@cdlout);
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+start_date/$start_date/ for (@cdlout);
    s/\+stop_date/$stop_date/ for (@cdlout);
    s/\+depth/$depth/ for (@cdlout);
    s/\+time/$timeline/ for (@cdlout);
    if ($pflg) {
	s/\+pres/$pres/ for (@cdlout);
    }
    if ($sflg) {
	s/\+speed/$speed/ for (@cdlout);
    }
    if ($dflg) { 
	s/\+direction/$direction/ for (@cdlout);
    }
    if ($uflg) { 
	s/\+ucomp/$u/ for (@cdlout);
    }
    if ($vflg) { 
	s/\+vcomp/$v/ for (@cdlout);
    }
    if ($tflg) {
	s/\+temp/$temp/ for (@cdlout);
    }
    if ($aflg) { 
	s/\+psal/$psal/ for (@cdlout);
    }

    return(@cdlout);
}

#
# Decode and convert the ITP level2 format used by Woods Hole Institute
# for Ice Tethered Platforms.
#
sub create_itp_cdl {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr,$timeunixref);
    my(@mytmp,$pname,$hours,$hourref,$timeofdata,$lat,$lon,$nvalues);
    my($nlat,$slat,$wlon,$elon);
    my($myvariables,$myunits,$thickness,$altitude,$myurl);
    my($myhistory,$start_date,$stop_date,$institution,$contact,$myarea);
    my($conventions,$distribution_statement,$project_name,$productname);
    my($topiccategory,$mykeywords,$mygcmdkeywords,$activity_type,$PI_name);
    my($line,$norec,$misvalin,$misvalout);
    my($itpid,$profileid,$vessel);
    my($myyear,$myday,$pressure,$temperature,$salinity);

    ###########################################################
    # Do some initialization
    $misvalin = "Nan";
    $misvalout = -999.;
    $title = "";
    $abstract = "The Ice-Tethered Profiler data were collected and made available by the Ice-Tethered Profiler Program based at the Woods Hole Oceanographic Institution (http://www.whoi.edu/itp). ITP data are similar to CTD data, but are collected from buoys frozen in the sea ice.";
    $productname = "ITP profile";
    $myarea = "Arctic Ocean";
    $topiccategory = "oceans";
    $mykeywords = "pressure,temperature,salinity";
    $mygcmdkeywords = "";
    $activity_type = "Ice station";
    $vessel = "";
    $myhistory = "";
    $distribution_statement = "Free";
    $conventions = "CF-1.0";
    $PI_name = "";
    $institution = "Woods Hole Oceanographic Institute";
    $contact = "itp\@whoi.edu";
    $myurl = "http://www.whoi.edu/itp/";
    $project_name = "Damocles";
    $start_date = "";
    $stop_date = "";


    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    # File records
    @mytmp = @$txtref;
    s/\ +/ /g for (@mytmp);
    s/^\ |\ $// for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	if ($norec == 0){
	    $line =~ s/^\%//;
	    @tmparr = (split /,/,$line);
	    $itpid = $tmparr[0];
	    $itpid =~ s/\D*//;
	    $profileid = (split /:/,$tmparr[1])[0];
	    $profileid =~ s/\D*//;
	    $norec++;
	    next;
	}
	if ($norec == 1) {
	    $line =~ s/^\ +/ /g;
	    @tmparr = (split / /,$line);
	    $myyear = $tmparr[0];
	    $myday = $tmparr[1];
	    $timeunix = year_and_day2epoch($myyear,$myday);
	    @timearr = gmtime($timeunix);
	    $timestr= strftime("%F %T UTC",@timearr);
	    $lon = $tmparr[2];
	    $lat = $tmparr[3];
	    $nvalues = $tmparr[4];
	    $norec++;
	    next;
	}
	if ($line =~ m/^\%/){
	    $norec++;
	    next;
	}
	@tmparr = split / /,$line;
	$myyear = $tmparr[0];
	$myday = $tmparr[1];
	$timeofdata .= year_and_day2epoch($myyear,$myday).",";
	$pressure .= $tmparr[2].",";
	$temperature .= $tmparr[3].",";
	$salinity .= $tmparr[4].",";
	$norec++;
    }
    warn "Data records: nvalues ($nvalues) and norec ($norec-4) differ\n" if ($nvalues != $norec-4);
    $timeofdata =~ s/,$//;
    $lat =~ s/,$//;
    $lon =~ s/,$//;
    $pressure =~ s/,$//;
    $salinity =~ s/,$//;
    $temperature =~ s/,$//;

    $title .= sprintf "ITP %02d Profile %06d",$itpid,$profileid;
    $vessel = sprintf "ITP %02d",$itpid;
    $myhistory = sprintf "%s creation",strftime("%F",gmtime(time));

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+title/$title/ for (@cdlout);
    s/\+abstract/$abstract/ for (@cdlout);
    s/\+topic/$topiccategory/ for (@cdlout);
    s/\+keyw/$mykeywords/ for (@cdlout);
    s/\+gcmdkeyw/$mygcmdkeywords/ for (@cdlout);
    s/\+area/$myarea/ for (@cdlout);
    s/\+inst/$institution/ for (@cdlout);
    s/\+url/$myurl/ for (@cdlout);
    s/\+piname/$PI_name/ for (@cdlout);
    s/\+email/$contact/ for (@cdlout);
    s/\+distribution/$distribution_statement/ for (@cdlout);
    s/\+pname/$productname/ for (@cdlout);
    s/\+projectname/$project_name/ for (@cdlout);
    s/\+activity/$activity_type/ for (@cdlout);
    s/\+history/$myhistory/ for (@cdlout);
    s/\+vessel/$vessel/ for (@cdlout);
    s/\+nlat/$lat/ for (@cdlout);
    s/\+slat/$lat/ for (@cdlout);
    s/\+wlon/$lon/ for (@cdlout);
    s/\+elon/$lon/ for (@cdlout);
    s/\+start_date/$timestr/ for (@cdlout);
    s/\+stop_date/$timestr/ for (@cdlout);
    s/\+nvalues/$nvalues/ for (@cdlout);
    s/\+time/$timeofdata/ for (@cdlout);
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+temperature/$temperature/ for (@cdlout);
    s/\+salinity/$salinity/ for (@cdlout);
    s/\+pressure/$pressure/ for (@cdlout);

    return(@cdlout);
}

#
# Decode and convert the column based ASCII format that can be used to
# store morring data. 
#
sub create_mooring_cdl_ascii {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr_start,$timestr_end,$timeunixref);
    my($timeunixref2007,$year,$month,$day,$hour);
    my(@mytmp,$pname,$timeofdata,$lat,$lon,$nvalues,$depth);
    my($myvariables,$myunits,$speed,$direction);
    my($pressure,$salinity,$temperature,$myurl,$platformname);
    my($myhistory,$start_date,$stop_date,$institution,$contact,$myarea);
    my($conventions,$distribution_statement,$project_name,$productname);
    my($topiccategory,$mykeywords,$mygcmdkeywords,$activity_type,$PI_name);
    my($line,$norec,$misvalin,$misvalout,$quality_statement);

    ###########################################################
    # Do some initialization
    $misvalin = "NaN";
    $misvalout = 9999.;
    $title = "";
    $abstract = "";
    $productname = "";
    $platformname = "";
    $myarea = "";
    $topiccategory = "";
    $mykeywords = "";
    $mygcmdkeywords = "";
    $activity_type = "";
    $myhistory = "";
    $distribution_statement = "";
    $conventions = "";
    $PI_name = "";
    $institution = "";
    $contact = "";
    $myurl = "";
    $project_name = "";
    $quality_statement = "";
    $start_date = "";
    $stop_date = "";


    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data
    # stream

    # title
    @mytmp = grep /^# title: /,@$txtref;
    unless ($#mytmp == -1) {
	$title = (split /:/,$mytmp[0])[1];
	$title =~ s/[\n\r]//g;
	$title =~ s/^\ //;
    }

    # abstract
    @mytmp = grep /^# abstract: /,@$txtref;
    unless ($#mytmp == -1) {
	$abstract = (split /:/,$mytmp[0])[1];
	$abstract =~ s/[\n\r]//g;
	$abstract =~ s/^\ //;
    }

    # topiccatergory
    @mytmp = grep /^# topiccategory: /,@$txtref;
    unless ($#mytmp == -1) {
	$topiccategory = (split /:/,$mytmp[0])[1];
	$topiccategory =~ s/[\n\r]//g;
	$topiccategory =~ s/,\ */ /g;
	$topiccategory =~ s/^\s//g;
    }

    # keywords
    @mytmp = grep /^# keywords: /,@$txtref;
    unless ($#mytmp == -1) {
	$mykeywords = (split /:/,$mytmp[0])[1];
	$mykeywords =~ s/^\s//g;
	$mykeywords =~ s/[\n\r]//g;
	$mykeywords =~ s/,/ /g;
    }

    # gcmd_keywords
    @mytmp = grep /^# gcmd_keywords: /,@$txtref;
    unless ($#mytmp == -1) {
	$mygcmdkeywords = (split /:/,$mytmp[0])[1];
	$mygcmdkeywords =~ s/^\s//g;
	$mygcmdkeywords =~ s/[\n\r]//g;
	$mygcmdkeywords =~ s/,/ /g;
    }

    # activity_type
    @mytmp = grep /^# activity_type: /,@$txtref;
    unless ($#mytmp == -1) {
	$activity_type = (split /:/,$mytmp[0])[1];
	$activity_type =~ s/[\n\r]//g;
	$activity_type =~ s/^\s//g;
    }

    # Conventions
    @mytmp = grep /^# Conventions: /,@$txtref;
    unless ($#mytmp == -1) {
	$conventions = (split /:/,$mytmp[0])[1];
	$conventions =~ s/[\n\r]//g;
    }

    # product_name
    @mytmp = grep /^# product_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$productname = (split /:/,$mytmp[0])[1];
	$productname =~ s/[\n\r]//g;
	$productname =~ s/^\s//g;
    }

    # platform_name
    @mytmp = grep /^# platform: /,@$txtref;
    unless ($#mytmp == -1) {
	$platformname = (split /:/,$mytmp[0])[1];
	$platformname =~ s/[\n\r]//g;
	$platformname =~ s/^\s//;
    }

    # Measurement level
    @mytmp = grep /^# measurement_level: /,@$txtref;
    unless ($#mytmp == -1) {
	$depth = (split /:/,$mytmp[0])[1];
	$depth =~ s/[\n\r]//g;
	die "Measurement level has to specified in meter" unless $depth =~ m/meter/;
	$depth =~ s/^\s//g;
	$depth =~ s/meter//g;
    }

    # history
    @mytmp = grep /^# history: /,@$txtref;
    unless ($#mytmp == -1) {
	$myhistory = (split /:/,$mytmp[0])[1];
	$myhistory =~ s/^\s//g;
	$myhistory =~ s/[\n\r]//g;
	$myhistory =~ s/,\s*/\n/g;
    }

    # area
    @mytmp = grep /^# area: /,@$txtref;
    unless ($#mytmp == -1) {
	$myarea = (split /:/,$mytmp[0])[1];
	$myarea =~ s/[\n\r]//g;
	$myarea =~ s/^\s//g;
    }

    # northernmost_latitude
    @mytmp = grep /^# northernmost_latitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$lat = (split /:/,$mytmp[0])[1];
	$lat =~ s/^ //;
	$lat =~ s/[\n\r]//g;
    }

    # southernmost_latitude
    @mytmp = grep /^# southernmost_latitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$lat = (split /:/,$mytmp[0])[1];
	$lat =~ s/^ //;
	$lat =~ s/[\n\r]//g;
    }

    # westernmost_longitude
    @mytmp = grep /^# westernmost_longitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$lon = (split /:/,$mytmp[0])[1];
	$lon =~ s/^ //;
	$lon =~ s/[\n\r]//g;
    }

    # easternmost_longitude
    @mytmp = grep /^# easternmost_longitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$lon = (split /:/,$mytmp[0])[1];
	$lon =~ s/^ //;
	$lon =~ s/[\n\r]//g;
    }

    # start_date
    @mytmp = grep /^# start_date: /,@$txtref;
    unless ($#mytmp == -1) {
	$start_date = (split /:/,$mytmp[0])[1];
	$start_date =~ s/[\n\r]//g;
	$timeunix = str2time($start_date,"UTC");
	$timeunixref = $timeunix;
	@timearr = gmtime($timeunix);
	$timestr_start = strftime("%F %T UTC",@timearr);
    }
    $timeunixref2007 = str2time("2007-01-01 00:00:00 UTC");
    $timeunixref -= $timeunixref2007;

    # stop_date
    @mytmp = grep /^# stop_date: /,@$txtref;
    unless ($#mytmp == -1) {
	$stop_date = (split /:/,$mytmp[0])[1];
	$stop_date =~ s/[\r\n]//g;
	$timeunix = str2time($stop_date,"UTC");
	@timearr = gmtime($timeunix);
	$timestr_end = strftime("%F %T UTC",@timearr);
    }

    # institution
    @mytmp = grep /^# institution: /,@$txtref;
    unless ($#mytmp == -1) {
	$institution = (split /:/,$mytmp[0])[1];
	$institution =~ s/[\n\r]//g;
	$institution =~ s/^\s//g;
    }

    # url
    @mytmp = grep /^# url: /,@$txtref;
    unless ($#mytmp == -1) {
	@tmparr = (split /:/,$mytmp[0]);
	$myurl = $tmparr[1].":".$tmparr[2];
	$myurl =~ s/[\n\r]//g;
	$myurl =~ s/^\s//g;
    }

    # PI_name
    @mytmp = grep /^# PI_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$PI_name = (split /:/,$mytmp[0])[1];
	$PI_name =~ s/[\n\r]//g;
	$PI_name =~ s/^\s//g;
    }

    # contact
    @mytmp = grep /^# contact: /,@$txtref;
    unless ($#mytmp == -1) {
	$contact = (split /:/,$mytmp[0])[1];
	$contact =~ s/[\s]//g;
    }

    # distribution_statement
    @mytmp = grep /^# distribution_statement: /,@$txtref;
    unless ($#mytmp == -1) {
	$distribution_statement = (split /:/,$mytmp[0])[1];
	$distribution_statement =~ s/[\n\r]//g;
	$distribution_statement =~ s/[\s]//;
    }

    # project_name
    @mytmp = grep /^# project_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$project_name = (split /:/,$mytmp[0])[1];
	$project_name =~ s/[\s]//g;
    }

    # quality statement
    @mytmp = grep /^# quality_statement: /,@$txtref;
    unless ($#mytmp == -1) {
	$quality_statement = (split /:/,$mytmp[0])[1];
	$quality_statement =~ s/^\s//g;
	$quality_statement =~ s/[\n\r]//g;
    }

    # variables
    @mytmp = grep /^# variables: /,@$txtref;
    unless ($#mytmp == -1) {
	$myvariables = (split /:/,$mytmp[0])[1];
	$myvariables =~ s/[\s]//g;
	die "Incorrect variables for this format specification" unless ($myvariables eq "year,month,day,hour,speed,dir,temp,salt,pres");
    }

    # units
    @mytmp = grep /^# units: /,@$txtref;
    unless ($#mytmp == -1) {
	$myunits = (split /:/,$mytmp[0])[1];
	$myunits =~ s/[\s]//;
	$myunits =~ s/[\r\n]//;
	unless ($myunits eq "NA,NA,NA,NA,cm/s,degrees from north,celsius,PSU,dbar") {
	print "$myunits\n";
	die "Incorrect unit specification for this format" 
	}
    }

    # Nvalues
    @mytmp = grep /^\# number of observations: /,@$txtref;
    unless ($#mytmp == -1) {
	$nvalues = (split /:/,$mytmp[0])[1];
	$nvalues =~ s/[\s\n\r]//g;
    }

    # Data records
    @mytmp = grep /^\d/,@$txtref;
    s/\ +/ /g for (@mytmp);
    s/^\ |\ $// for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	next if (length($line) == 0);
	@tmparr = split / /,$line;
	$year = $tmparr[0];
	$month = $tmparr[1];
	$day = $tmparr[2];
	$hour = $tmparr[3];
	$timeunix = str2time(sprintf("%4d-%02d-%02d %02d:00:00 UTC",$year,$month,$day,$hour),"UTC");
	$timeofdata .= "$timeunix,"; 
	$speed .= "$tmparr[4],";
	$direction .= "$tmparr[5],";
	$temperature .= "$tmparr[6],";
	$salinity .= "$tmparr[7],";
	$pressure .= "$tmparr[8],";
	$norec++;
    }
    warn "Data records: nvalues ($nvalues) and norec ($norec) differ\n" if ($nvalues != $norec);
    $timeofdata =~ s/,$//;
    $speed =~ s/,$//;
    $speed =~ s/$misvalin/$misvalout/g;
    $direction =~ s/,$//;
    $direction =~ s/$misvalin/$misvalout/g;
    $temperature =~ s/,$//;
    $temperature =~ s/$misvalin/$misvalout/g;
    $salinity =~ s/,$//;
    $salinity =~ s/$misvalin/$misvalout/g;
    $pressure =~ s/,$//;
    $pressure =~ s/$misvalin/$misvalout/g;

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+title/$title/ for (@cdlout);
    s/\+abstract/$abstract/ for (@cdlout);
    s/\+topic/$topiccategory/ for (@cdlout);
    s/\+keyw/$mykeywords/ for (@cdlout);
    s/\+gcmdkeyw/$mygcmdkeywords/ for (@cdlout);
    s/\+area/$myarea/ for (@cdlout);
    s/\+inst/$institution/ for (@cdlout);
    s/\+url/$myurl/ for (@cdlout);
    s/\+piname/$PI_name/ for (@cdlout);
    s/\+email/$contact/ for (@cdlout);
    s/\+distribution/$distribution_statement/ for (@cdlout);
    s/\+pname/$productname/ for (@cdlout);
    s/\+projectname/$project_name/ for (@cdlout);
    s/\+vessel/$platformname/ for (@cdlout);
    s/\+quality/$quality_statement/ for (@cdlout);
    s/\+activity/$activity_type/ for (@cdlout);
    s/\+history/$myhistory/ for (@cdlout);
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+start_date/$timestr_start/ for (@cdlout);
    s/\+stop_date/$timestr_end/ for (@cdlout);
    s/\+nlevels/1/ for (@cdlout);
    s/\+depth/$depth/ for (@cdlout);
    s/\+time/$timeofdata/ for (@cdlout);
    s/\+speed/$speed/ for (@cdlout);
    s/\+direction/$direction/ for (@cdlout);
    s/\+pres/$pressure/ for (@cdlout);
    s/\+temp/$temperature/ for (@cdlout);
    s/\+psal/$salinity/ for (@cdlout);

    return(@cdlout);
}


#
# Decode and convert a specific trajectory format used by AWI for ice
# thickness measurements from helicopter.
#
sub create_trajectory_cdl_awiem {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my(@timearr,$timeunix,$timestr_start,$timestr_end,$timeunixref);
    my($timeunixref2007);
    my(@mytmp,$pname,$hours,$hourref,$timeofdata,$lat,$lon,$nvalues);
    my($nlat,$slat,$wlon,$elon);
    my($myvariables,$myunits,$thickness,$altitude,$myurl);
    my($myhistory,$start_date,$stop_date,$institution,$contact,$myarea);
    my($conventions,$distribution_statement,$project_name,$productname);
    my($topiccategory,$mykeywords,$mygcmdkeywords,$activity_type,$PI_name);
    my($line,$norec,$misvalin,$misvalout,$quality_statement);

    ###########################################################
    # Do some initialization
    $misvalin = "Nan";
    $misvalout = -999.;
    $title = "";
    $abstract = "";
    $productname = "";
    $myarea = "";
    $topiccategory = "";
    $mykeywords = "";
    $mygcmdkeywords = "";
    $activity_type = "";
    $myhistory = "";
    $distribution_statement = "";
    $conventions = "";
    $PI_name = "";
    $institution = "";
    $contact = "";
    $myurl = "";
    $project_name = "";
    $quality_statement = "";
    $start_date = "";
    $stop_date = "";


    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # First the necessary information is extracted from the input data
    # stream

    # title
    @mytmp = grep /^# title: /,@$txtref;
    unless ($#mytmp == -1) {
	$title = (split /:/,$mytmp[0])[1];
	$title =~ s/[\n\r]//g;
	$title =~ s/^\ //;
    }

    # abstract
    @mytmp = grep /^# abstract: /,@$txtref;
    unless ($#mytmp == -1) {
	$abstract = (split /:/,$mytmp[0])[1];
	$abstract =~ s/[\n\r]//g;
	$abstract =~ s/^\ //;
    }

    # topiccatergory
    @mytmp = grep /^# topiccategory: /,@$txtref;
    unless ($#mytmp == -1) {
	$topiccategory = (split /:/,$mytmp[0])[1];
	$topiccategory =~ s/[\n\r]//g;
	$topiccategory =~ s/,\ */ /g;
	$topiccategory =~ s/^\s//g;
    }

    # keywords
    @mytmp = grep /^# keywords: /,@$txtref;
    unless ($#mytmp == -1) {
	$mykeywords = (split /:/,$mytmp[0])[1];
	$mykeywords =~ s/^\s//g;
	$mykeywords =~ s/[\n\r]//g;
	$mykeywords =~ s/,/ /g;
    }

    # gcmd_keywords
    @mytmp = grep /^# gcmd_keywords: /,@$txtref;
    unless ($#mytmp == -1) {
	$mygcmdkeywords = (split /:/,$mytmp[0])[1];
	$mygcmdkeywords =~ s/^\s//g;
	$mygcmdkeywords =~ s/[\n\r]//g;
	$mygcmdkeywords =~ s/,/ /g;
    }

    # activity_type
    @mytmp = grep /^# activity_type: /,@$txtref;
    unless ($#mytmp == -1) {
	$activity_type = (split /:/,$mytmp[0])[1];
	$activity_type =~ s/[\n\r]//g;
	$activity_type =~ s/^\s//g;
    }

    # Conventions
    @mytmp = grep /^# Conventions: /,@$txtref;
    unless ($#mytmp == -1) {
	$conventions = (split /:/,$mytmp[0])[1];
	$conventions =~ s/[\n\r]//g;
    }

    # product_name
    @mytmp = grep /^# product_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$productname = (split /:/,$mytmp[0])[1];
	$productname =~ s/[\n\r]//g;
	$productname =~ s/^\s//g;
    }

    # history
    @mytmp = grep /^# history: /,@$txtref;
    unless ($#mytmp == -1) {
	$myhistory = (split /:/,$mytmp[0])[1];
	$myhistory =~ s/^\s//g;
	$myhistory =~ s/[\n\r]//g;
	$myhistory =~ s/,\s*/\n/g;
    }

    # area
    @mytmp = grep /^# area: /,@$txtref;
    unless ($#mytmp == -1) {
	$myarea = (split /:/,$mytmp[0])[1];
	$myarea =~ s/[\n\r]//g;
	$myarea =~ s/^\s//g;
    }

    # northernmost_latitude
    @mytmp = grep /^# northernmost_latitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$nlat = (split /:/,$mytmp[0])[1];
	$nlat =~ s/^ //;
	$nlat =~ s/[\n\r]//g;
    }

    # southernmost_latitude
    @mytmp = grep /^# southernmost_latitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$slat = (split /:/,$mytmp[0])[1];
	$slat =~ s/^ //;
	$slat =~ s/[\n\r]//g;
    }

    # westernmost_longitude
    @mytmp = grep /^# westernmost_longitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$wlon = (split /:/,$mytmp[0])[1];
	$wlon =~ s/^ //;
	$wlon =~ s/[\n\r]//g;
    }

    # easternmost_longitude
    @mytmp = grep /^# easternmost_longitude: /,@$txtref;
    unless ($#mytmp == -1) {
	$elon = (split /:/,$mytmp[0])[1];
	$elon =~ s/^ //;
	$elon =~ s/[\n\r]//g;
    }

    # start_date
    @mytmp = grep /^# start_date: /,@$txtref;
    unless ($#mytmp == -1) {
	$start_date = (split /:/,$mytmp[0])[1];
	$start_date =~ s/[\n\r]//g;
	$timeunix = str2time($start_date,"UTC");
	$timeunixref = $timeunix;
	@timearr = gmtime($timeunix);
	$timestr_start = strftime("%F %T UTC",@timearr);
    }
    $timeunixref2007 = str2time("2007-01-01 00:00:00 UTC");
    $timeunixref -= $timeunixref2007;

    # stop_date
    @mytmp = grep /^# stop_date: /,@$txtref;
    unless ($#mytmp == -1) {
	$stop_date = (split /:/,$mytmp[0])[1];
	$stop_date =~ s/[\r\n]//g;
	$timeunix = str2time($stop_date,"UTC");
	@timearr = gmtime($timeunix);
	$timestr_end = strftime("%F %T UTC",@timearr);
    }

    # institution
    @mytmp = grep /^# institution: /,@$txtref;
    unless ($#mytmp == -1) {
	$institution = (split /:/,$mytmp[0])[1];
	$institution =~ s/[\n\r]//g;
	$institution =~ s/^\s//g;
    }

    # url
    @mytmp = grep /^# url: /,@$txtref;
    unless ($#mytmp == -1) {
	@tmparr = (split /:/,$mytmp[0]);
	$myurl = $tmparr[1].":".$tmparr[2];
	$myurl =~ s/[\n\r]//g;
	$myurl =~ s/^\s//g;
    }

    # PI_name
    @mytmp = grep /^# PI_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$PI_name = (split /:/,$mytmp[0])[1];
	$PI_name =~ s/[\n\r]//g;
	$PI_name =~ s/^\s//g;
    }

    # contact
    @mytmp = grep /^# contact: /,@$txtref;
    unless ($#mytmp == -1) {
	$contact = (split /:/,$mytmp[0])[1];
	$contact =~ s/[\s]//g;
    }

    # distribution_statement
    @mytmp = grep /^# distribution_statement: /,@$txtref;
    unless ($#mytmp == -1) {
	$distribution_statement = (split /:/,$mytmp[0])[1];
	$distribution_statement =~ s/[\s]//g;
    }

    # project_name
    @mytmp = grep /^# project_name: /,@$txtref;
    unless ($#mytmp == -1) {
	$project_name = (split /:/,$mytmp[0])[1];
	$project_name =~ s/[\s]//g;
    }

    # quality statement
    @mytmp = grep /^# quality_statement: /,@$txtref;
    unless ($#mytmp == -1) {
	$quality_statement = (split /:/,$mytmp[0])[1];
	$quality_statement =~ s/^\s//g;
	$quality_statement =~ s/[\n\r]//g;
    }

    # variables
    @mytmp = grep /^# variables: /,@$txtref;
    unless ($#mytmp == -1) {
	$myvariables = (split /:/,$mytmp[0])[1];
	$myvariables =~ s/[\s]//g;
	die "Incorrect variables for this format specification" unless ($myvariables eq "latitude,longitude,time,thickness,altitude");
    }

    # units
    @mytmp = grep /^# units: /,@$txtref;
    unless ($#mytmp == -1) {
	$myunits = (split /:/,$mytmp[0])[1];
	$myunits =~ s/[\s]//g;
	die "Incorrect unit specification for this format" unless ($myunits eq "degrees_North,degrees_East,hours,meter,meter");
    }

    # Nvalues
    @mytmp = grep /^\# number of observations: /,@$txtref;
    unless ($#mytmp == -1) {
	$nvalues = (split /:/,$mytmp[0])[1];
	$nvalues =~ s/[\s\n\r]//g;
    }

    # Data records
    @mytmp = grep /^\s/,@$txtref;
    s/\ +/ /g for (@mytmp);
    s/^\ |\ $// for (@mytmp);
    s/[\n\r]//g for (@mytmp);
    $norec = 0;
    foreach $line (@mytmp) {
	next if (length($line) == 0);
	@tmparr = split / /,$line;
	$lat .= "$tmparr[0],";
	$lon .= "$tmparr[1],";
	$hours = $tmparr[2];
	$hourref = int($hours) if ($norec == 0);
	#$timeunix = int(($hours-$hourref)*3600);
	$timeunix = int(($hours-$hourref)*3600*1000);
	##print "$hours $hourref $timeunix ";
	$timeunix += ($timeunixref*1000);
	##print "$timeunix $timeunixref\n";
	$timeofdata .= "$timeunix,"; 
	$thickness .= "$tmparr[3],";
	$altitude .= "$tmparr[4],";
	$norec++;
    }
    warn "Data records: nvalues ($nvalues) and norec ($norec) differ\n" if ($nvalues != $norec);
    $timeofdata =~ s/,$//;
    $lat =~ s/,$//;
    $lon =~ s/,$//;
    $hours =~ s/,$//;
    $thickness =~ s/,$//;
    $thickness =~ s/$misvalin/$misvalout/g;
    $altitude =~ s/,$//;
    $altitude =~ s/$misvalin/$misvalout/g;

    ########################################################### 
    # Then this information is substituted into the CDL template

    s/\+title/$title/ for (@cdlout);
    s/\+abstract/$abstract/ for (@cdlout);
    s/\+topic/$topiccategory/ for (@cdlout);
    s/\+keyw/$mykeywords/ for (@cdlout);
    s/\+gcmdkeyw/$mygcmdkeywords/ for (@cdlout);
    s/\+area/$myarea/ for (@cdlout);
    s/\+inst/$institution/ for (@cdlout);
    s/\+url/$myurl/ for (@cdlout);
    s/\+piname/$PI_name/ for (@cdlout);
    s/\+email/$contact/ for (@cdlout);
    s/\+distribution_statement/$distribution_statement/ for (@cdlout);
    s/\+pname/$productname/ for (@cdlout);
    s/\+projectname/$project_name/ for (@cdlout);
    s/\+quality/$quality_statement/ for (@cdlout);
    s/\+activity/$activity_type/ for (@cdlout);
    s/\+history/$myhistory/ for (@cdlout);
    s/\+nlat/$nlat/ for (@cdlout);
    s/\+slat/$slat/ for (@cdlout);
    s/\+wlon/$wlon/ for (@cdlout);
    s/\+elon/$elon/ for (@cdlout);
    s/\+start_date/$timestr_start/ for (@cdlout);
    s/\+stop_date/$timestr_end/ for (@cdlout);
    s/\+time/$timeofdata/ for (@cdlout);
    s/\+lat/$lat/ for (@cdlout);
    s/\+lon/$lon/ for (@cdlout);
    s/\+thickness/$thickness/ for (@cdlout);
    s/\+altitude/$altitude/ for (@cdlout);

    return(@cdlout);
}

#
# Decode and convert to CDL the METNO radiative flux file format
#
sub create_timeseries_cdl_radflux {
    my(@cdlout,@tmparr);
    my($tempref,$txtref) = @_;
    my($norec);
    my($stationname,$variables,$datalogger,$procmeth);
    my $varnames = "TIMESTAMP,RECORD,P_Wpm2_Avg,T_gr_C_Avg,P_L_Wpm2_Avg,T_L_gr_C_Avg,Batt_V_Min";
    my $varmeth = ",,Avg,Avg,Avg,Avg,Min";
    my($timestr,$timestr_start,$timestr_end,$obstime,$unixtime);
    my($ssi,$dli,$ssitemp,$dlitemp,$battmin,$nvalues);
    my($misvalin,$misvalout);
    my($topiccategory,$keywords,$gcmdkeywords,$conventions,$history);
    my %stationinfo = 
    (
	"Bjørnøya" => {
	    "title" => "Downwelling surface radiative fluxes at Bear Island",
	    "abstract" => "Downwelling surface radiative fluxes observed at the meteorological station at Bear Island in the Barents Sea. Measurements are made using Kipp and Zonen CMP21 and CGR4 pyranometers and pyrgeometers. Daily maintenance is performed by the meteorological personnel at the station. Data are averaged over the last minute and the time is set to UTC. This data set has been collected with support from the Norwegian Research Council.", 
	    "product_name" => "radiative fluxes",
	    "history" => "2008-10-23 creation",
	    "project_name" => "iAOOS-Norway/IPY-THORPEX",
	    "area" => "Ocean > Arctic Ocean > Barents Sea",
	    "lat" => 74.5166667,
	    "lon" => 19.01666667,
	    "institution" => "Norwegian Meteorological Institute",
	    "PI_name" => "Øystein Godøy",
	    "url" => "http://www.met.no/",
	    "contact" => "o.godoy\@met.no",
	    "distribution_statement" => "Free",
	    "quality_statement" => "Quality controlled",
	},
	"Jan Mayen" => {
	    "title" => "Downwelling surface radiative fluxes at Jan Mayen",
	    "abstract" => "Downwelling surface radiative fluxes observed at the meteorological station at Jan Mayen Island in the Greenland Sea. Measurements are made using Kipp and Zonen CMP21 and CGR4 pyranometers and pyrgeometers. Daily maintenance is performed by the meteorological personnel at the station. Data are averaged over the last minute and the time is set to UTC. This data set has been collected with support from the Norwegian Research Council.",
	    "product_name" => "radiative fluxes",
	    "history" => "2008-11-23 creation",
	    "project_name" => "iAOOS-Norway",
	    "area" => "Ocean > Arctic Ocean > Greenland Sea",
	    "lat" => 70.933333,
	    "lon" => -8.6666667,
	    "institution" => "Norwegian Meteorological Institute",
	    "PI_name" => "Øystein Godøy",
	    "url" => "http://www.met.no/",
	    "contact" => "o.godoy\@met.no",
	    "distribution_statement" => "Free",
	    "quality_statement" => "Quality controlled",
	},
	"unknown" => {
	    "title" => "",
	    "abstract" => "",
	    "product_name" => "",
	    "history" => "",
	    "project_name" => "",
	    "area" => "",
	    "lat" => -999.,
	    "lon" => -999.,
	    "institution" => "",
	    "PI_name" => "",
	    "url" => "",
	    "contact" => "",
	    "distribution_statement" => "",
	    "quality_statement" => "",
	},
    );

    $misvalin = "NAN";
    $misvalout = -999.;
    $topiccategory = "ClimatologyMeteorologyAtmosphere";
    $keywords = "Radiative Flux";
    $gcmdkeywords = 
	"Atmosphere > Atmospheric Radiation > Shortwave Radiation\n".
	"Atmosphere > Atmospheric Radiation > Longwave Radiation";

    ###########################################################
    # Copy the template
    @cdlout = @$tempref;

    ########################################################### 
    # Decode header - 4 records
    #
    $norec = 0;
    foreach $line (@$txtref) {
	$line =~ s/["\n\r]//g;
	if ($norec == 0) {
	    @tmparr = split /,/,$line;
	    $stationname = $tmparr[1];
	    $stationname =~ s/ Strålingsstasjon//;
	    $datalogger = $tmparr[2];
	}
	if ($norec==1) {
	    $variables = $line; 
	    die "Variable names do not match" if ($variables ne $varnames);
	}
	if ($norec==3) {
	    $procmeth = $line; 
	    die "Variable processing do not match" if ($procmeth ne $varmeth);
	}
	$norec++;
	last if ($norec == 4);
    }

    ###########################################################
    # History update
    #
    if (length($stationinfo{$stationname}{history}) > 0) {
	$history = $stationinfo{$stationname}{history}."\n".sprintf "%s revision",strftime("%F",gmtime(time));
    } else {
	$history = sprintf "%s creation",strftime("%F",gmtime(time));
    }

    ########################################################### 
    # Decode data records - 7 variables
    #
    $norec = 0;
    foreach $line (@$txtref) {
	$line =~ s/["\n\r]//g;
	$norec++;
	next if ($norec < 5);
	$line =~ s/["\n\r]//g;
	@tmparr = split /,/,$line;
	$unixtime = str2time($tmparr[0],"UTC");
	$obstime .= $unixtime.",";
	$timestr_start = strftime("%Y-%m-%d %H:%M UTC",gmtime($unixtime)) if ($norec==5);
	$timestr_end = strftime("%Y-%m-%d %H:%M UTC",gmtime($unixtime));
	$nvalues = $tmparr[1];
	$ssi .= $tmparr[2].",";
	$ssitemp .= $tmparr[3].",";
	if (abs($tmparr[4]) > 200) {
	    $dli .= $misvalout.",";
	} else {
	    $dli .= $tmparr[4].",";
	}
	$dlitemp .= $tmparr[5].",";
	$battmin .= $tmparr[6].",";
    }
    ##warn "Data records: nvalues ($nvalues) and norec ($norec) differ\n" if ($nvalues != $norec-4);

    ###########################################################
    # Clean records
    #
    $obstime =~ s/,$//;
    $ssi =~ s/,$//;
    $ssi =~ s/$misvalin/$misvalout/g;
    $ssitemp =~ s/,$//;
    $ssitemp =~ s/$misvalin/$misvalout/g;
    $dli =~ s/,$//;
    $dli =~ s/$misvalin/$misvalout/g;
    $dlitemp =~ s/,$//;
    $dlitemp =~ s/$misvalin/$misvalout/g;
    $battmin =~ s/,$//;
    $battmin =~ s/$misvalin/$misvalout/g;

    ###########################################################
    # Enter values into the CDL template
    #
    s/\+history/$history/ for (@cdlout);
    s/\+title/$stationinfo{$stationname}{title}/ for (@cdlout);
    s/\+abstract/$stationinfo{$stationname}{abstract}/ for (@cdlout);
    s/\+pname/$stationinfo{$stationname}{product_name}/ for (@cdlout);
    s/\+area/$stationinfo{$stationname}{area}/ for (@cdlout);
    s/\+topic/$topiccategory/ for (@cdlout);
    s/\+keyw/$keywords/ for (@cdlout);
    s/\+gcmdkeyw/$gcmdkeywords/ for (@cdlout);
    s/\+piname/$stationinfo{$stationname}{PI_name}/ for (@cdlout);
    s/\+inst/$stationinfo{$stationname}{institution}/ for (@cdlout);
    s/\+url/$stationinfo{$stationname}{url}/ for (@cdlout);
    s/\+email/$stationinfo{$stationname}{contact}/ for (@cdlout);
    s/\+distribution/$stationinfo{$stationname}{distribution_statement}/ for (@cdlout);
    s/\+qual/$stationinfo{$stationname}{quality_statement}/ for (@cdlout);
    s/\+lat/$stationinfo{$stationname}{lat}/ for (@cdlout);
    s/\+lon/$stationinfo{$stationname}{lon}/ for (@cdlout);
    s/\+stationid/$stationname/ for (@cdlout);
    s/\+time/$obstime/ for (@cdlout);
    s/\+start_date/$timestr_start/ for (@cdlout);
    s/\+stop_date/$timestr_end/ for (@cdlout);
    s/\+ssi/$ssi/ for (@cdlout);
    s/\+tempssi/$ssitemp/ for (@cdlout);
    s/\+dli/$dli/ for (@cdlout);
    s/\+tempdli/$dlitemp/ for (@cdlout);
    s/\+battmin/$battmin/ for (@cdlout);

    return(@cdlout);
}
